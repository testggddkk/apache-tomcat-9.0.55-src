# 深入理解synchronized

应用场景： 解决线程安全问题

加锁： 序列化的访问临界资源

java中的实现 :    阻塞： synchronized reentrantLock

​                            非阻塞：  cas+自旋



# [synchronized的使用](#3460-1631601809082)

方式：  方法上    代码块中    （锁对象）

## 原理

jvm指令：  方法上（acc_synchronized ）  代码块（ monitorenter monitorexit）

管程（Monitor): java锁体系的设计思想，设计理论基础

MESA：  入口等待队列 （互斥）     多个条件队列 （同步    阻塞唤醒机制）

java实现monitor:    Object     wait/notify/notifyAll     重量级操作 ： （用户态到内核态的切换） 

优化： 重量级锁     偏向锁   轻量级锁

偏向锁： 不存在竞争       偏向某个线程     thread1,后续进入同步块的逻辑没有加锁解锁的开销

轻量级锁： 线程间存在轻微的竞争（线程交替执行，临界区逻辑简单）  CAS获取锁，失败膨胀

重量级锁：  多线程竞争激烈的场景     膨胀期间创建一个monitor对象      CAS自旋     阻塞

加锁/解锁      加锁解锁的标记    识别是哪种锁（锁状态）

synchronized加锁加在对象上，锁对象是如何记录锁状态的？

**对象的内存布局**          MarkWord

![img](G:\我的文档\云笔记\chaosbead@163.com(1)\1a5af8281c1a40e9ab664a285a4307a5\clipboard.png)

跟踪锁状态如何变化的？  

误区：

关于偏向锁轻量级锁重量级锁存在的理解误区:

1. 无锁——>偏向锁——>轻量级锁——>重量级2锁       （不存在无锁——>偏向锁）

   2.轻量级锁自旋获取锁失败，会膨胀升级为重量级锁             （轻量级锁不存在自旋）

3. 重量级锁不存在自旋     （重量级锁存在自旋 ）



jvm对synchronized的优化

针对偏向锁（偏向锁撤销存在性能问题）  批量重偏向  批量撤销

针对重量级锁 ：  自旋优化  自适应自旋

锁粗化， 锁消除



